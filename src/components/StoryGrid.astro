---
const { stories } = Astro.props

let { lang } = Astro.params

if (!lang) {
	// Read path parameters for language and slug
	const { path } = Astro.params

	const pathParams = path?.toString().split('/')
	lang = pathParams?.[0] || 'en'
}
---

<div dir='ltr' id='grid' class='grid'></div>

<style is:global lang='scss'>
	body.is-dragging .story-item h2,
	body.is-dragging .story-item {
		cursor: move;
	}

	/* Hide images when dragging */
	#grid.hide-images {
		.story-item img {
			opacity: 0;
		}

		.story-item h2 {
			background: white;
			color: black;
		}
	}

	/* Grid view styles */
	.stories-container--grid span {
		display: grid;
		position: fixed;
		z-index: 5000;
		top: 0;
		left: 0;
		width: 50px;
		height: 50px;
		background: white;
	}

	.grid {
		display: grid;
		width: 100%;
		height: 100%;
		gap: 0;
		overflow: hidden;

		gap: 1rem;

		@media screen and (max-width: 500px) {
			gap: 1rem;
		}
	}

	#grid .story-item {
		position: relative;
		background-size: cover;
		image-rendering: pixelated;
		background-position: center center;
		user-select: none;
		overflow: hidden;
		will-change: auto;
		transform: scale(1);
		padding-top: 0.1rem;

		h2 {
			font-family: 'Roboto', sans-serif;
			font-weight: 500;
			line-height: 1.15;
			// text-shadow: 2px 2px 15px rgba(0, 0, 0, 1);
		}

		img {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
			width: 100%;
			height: 100%;
			object-fit: cover;
			pointer-events: none;
		}

		&.highlighted {
			scale: 1.05;
			z-index: 999;
			border: 0.5rem solid #9f3e52;
			box-shadow: 0 0 15px black;
			// align-items: end;
			// justify-items: end;
			// display: flex;

			@media screen and (max-width: 500px) {
				display: unset;
			}

			h2 {
				font-weight: 500;
				line-height: 1.25;
				align-self: end;
				padding: 0.25rem 0.5rem;
				background: #9f3e52;
				color: white;
				margin-left: -1px;
				margin-top: -1px;

				@media screen and (max-width: 500px) {
					margin-left: 1px;
					font-weight: bold;
				}
			}

			&:hover {
				border-color: white;

				h2 {
					background: transparent;
				}
			}
		}
	}

	.full-image {
		opacity: 0;

		&.loaded {
			opacity: 1;
		}
	}

	#grid.filter--read .story-item:not([data-lastread='never']) {
		opacity: 0.2;
		/* transition: opacity 0.1s ease-out 1; */
	}

	#grid.filter--read .story-item:not([data-lastread='never']),
	#grid.filter--read .story-item:not([data-lastread='never']) * {
		/* pointer-events: none; */
	}

	#grid.filter--read .story-item:not([data-lastread='never']):hover,
	#grid.filter--read .story-item:not([data-lastread='never']):hover * {
		cursor: move;
	}

	.story-item--title {
		display: inline;
		margin: 0;
		box-decoration-break: clone;
		font-size: 1.2rem;
		line-height: 1.15;
		top: 0;

		@media screen and (max-width: 500px) {
			display: inline;
			margin: 0;
			top: 0;
			position: absolute;
			text-align: left;
			font-size: 1.15rem;
			padding: 0.55rem;
			font-weight: bold;
			/* Line clamp */
			/* display: -webkit-box; */
			// -webkit-line-clamp: 2;
			// -webkit-box-orient: vertical;
			// overflow: hidden;
			// text-overflow: ellipsis;
		}
	}

	.language--ar .story-item {
		direction: rtl;
		text-align: right;
	}

	@keyframes opacityChange {
		50% {
			opacity: 1;
		}
		100% {
			opacity: 0.5;
		}
	}
</style>

<!-- Library to help moving around the grid -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js' is:inline></script>

<script async define:vars={{ stories, lang }} is:inline>
	// Initial check to filter grid if necessary, same for list
	function filterGridBasedOnLocalStorage() {
		if (localStorage.getItem('showAll') === 'false') {
			document.getElementById('grid').classList.add('filter--read')
			document.getElementById('list').classList.add('filter--read')
		} else {
			document.getElementById('grid').classList.remove('filter--read')
			document.getElementById('list').classList.remove('filter--read')
		}
	}

	// Window load event
	window.addEventListener('DOMContentLoaded', function () {
		filterGridBasedOnLocalStorage()

		const grid = optimalGridDimensions()

		Infinite.setGrid(grid.cols, grid.rows).then(() => {
			Infinite.updateGridBackground('black') // Add this line
		})
	})

	function truncateWithEllipses(text, maxLength) {
		if (text.length <= maxLength) {
			return text
		}
		return text.substr(0, maxLength - 3) + '...' // Subtract 3 for the length of the ellipses
	}

	let allStories = []

	/* Grid magic */
	class GridItem {
		constructor(index) {
			// Create anchor element for grid item as a container
			this.item = document.createElement('a')

			// Add data-astro-prefetch to the anchor element
			this.item.setAttribute('data-astro-prefetch', 'true')

			// Variable to check if currently loading image
			this.currentLoadingImage = null

			if (lang === 'en') {
				// Create h2 element for the English title
				this.titleEnglish = document.createElement('h2')
				this.item.append(this.titleEnglish)
			}

			if (lang === 'ar') {
				// Create h2 element for the Arabic title
				this.titleArabic = document.createElement('h2')
				this.item.append(this.titleArabic)
			}

			this.visibleBeforeDrag = true

			// Set index and add classes
			// this.index = index)

			this.item.classList.add('story-item')
			// this.setNewCard()
		}

		// Method to check if this item is highlighted
		isHighlighted() {
			// Check if the item's element has the 'highlighted' class
			return this.item.classList.contains('highlighted')
		}

		setIndex(index) {
			this.index = index
			this.setNewCard()
		}

		isImageLoaded() {
			return this.item.querySelector('img') !== null
		}

		// Method to check if this item is within the viewport (or visible area)
		checkVisibility() {
			const rect = this.item.getBoundingClientRect()
			const isVisible = (rect.top * 0.75) < window.innerHeight && rect.bottom > window.innerHeight * 0.25 // Simple visibility check

			return isVisible
		}

		setNewCard() {
			// Define vars to be used later
			let story = stories[this.index % stories.length]

			const visibleBeforeDrag = this.visibleBeforeDrag
			const currentlyVisible = this.checkVisibility()

			if (visibleBeforeDrag && currentlyVisible) {
				// Keep story
			} else if (visibleBeforeDrag && !currentlyVisible) {
				// Keep story
			} else {
				// Select random story from stories array and store in story variable
				story = stories[Math.floor(Math.random() * stories.length)]
				// Add to allStories array if not already there
				if (!allStories.includes(story.id)) {
					allStories.push(story.id)
				} else {
					// If story is already in allStories array, select another random story
					story = stories[Math.floor(Math.random() * stories.length)]
				}
				console.log('Number of loaded stories: ', allStories.length)
        if (allStories.length === stories.length) {
          console.log('All stories loaded')
          console.log(allStories)
        }
			}

			// Add both language titles
			const titles = {
				ar: story.story['ar'].title || `Arabic title for story with ID ${story.id} is missing.`,
				en: story.story['en'].title || `English title for story with ID ${story.id} is missing`,
			}

			// Determine the new image URL
			// Extract URLs for the main and pixelated images
			let newImageUrl = story.storyImage.main
			let pixelatedImageUrl = story.storyImage.pixelated

			// Check if there's already an <img> element inside the grid-item
			let currentImageElement = this.item.querySelector('img')

			// If there's an image and its source is the same as the new image, return early
			if (currentImageElement && currentImageElement.src === newImageUrl) {
				return
			}

			// Set the background to the placeholder
			this.item.style.backgroundImage = `url('${pixelatedImageUrl}')`
			this.item.style.backgroundSize = 'cover'
			this.item.style.backgroundPosition = 'center'
			this.item.classList.add('group')
			this.item.style.width = '100%'
			this.item.style.height = '100%'

			// Check for initial load to decide between lazy loading or direct image set
			if (this.initialLoad) {
				this.lazyLoadImage(story.storyImage.main, story.titles[lang])
			} else {
				const imageElement = document.createElement('img')
				imageElement.src = newImageUrl
				imageElement.classList.add('full-image')
				imageElement.classList.add('loaded') // Immediately show it, since we're not lazy loading now
				this.item.appendChild(imageElement)
			}

			// Check if article was read before and write date of last read if that's the case
			let readArticles = JSON.parse(localStorage.getItem('readArticles')) || []
			let readArticle = readArticles.find((article) => article.slug === story.slugs[lang])
			if (readArticle) {
				// If the current article has been read before, set the data-lastread attribute with the timestamp
				this.item.setAttribute('data-lastread', readArticle.timestamp)
			} else {
				// If the current article has not been read, set data-lastread to a default value or omit this part altogether
				this.item.setAttribute('data-lastread', 'never')
			}

			if (lang === 'en') {
				// Set English title for the grid item
				this.titleEnglish.textContent = truncateWithEllipses(titles['en'], 100)

				// Set title classes and add text for English title
				this.titleEnglish.classList.add('story-item--title')
				this.titleEnglish.classList.add('lang--en')
				this.titleEnglish.classList.add('box-decoration-clone')
				this.titleEnglish.classList.add('px-2')
				this.titleEnglish.classList.add('tracking-tight')
				this.titleEnglish.classList.add('text-white')
				this.titleEnglish.classList.add('sm:text-black')
				this.titleEnglish.classList.add('bg-transparent')
				this.titleEnglish.classList.add('sm:bg-white')
				this.titleEnglish.classList.add('sm:group-hover:text-shadow-lg')
				this.titleEnglish.classList.add('shadow-black')
				this.titleEnglish.classList.add('sm:group-hover:text-white')
				this.titleEnglish.classList.add('sm:group-hover:bg-transparent')
				this.titleEnglish.classList.add('pointer-events-none')
				this.titleEnglish.setAttribute('dir', 'ltr')
			}

			if (lang === 'ar') {
				// Set Arabic title for the grid item
				this.titleArabic.textContent = truncateWithEllipses(titles['ar'], 100)

				// Set title classes and add text for Arabic title
				this.titleArabic.classList.add('story-item--title')
				this.titleArabic.classList.add('lang--ar')
				this.titleArabic.classList.add('box-decoration-clone')
				this.titleArabic.classList.add('px-2')
				this.titleArabic.classList.add('tracking-tight')
				this.titleArabic.classList.add('text-white')
				this.titleArabic.classList.add('sm:text-black')
				this.titleArabic.classList.add('bg-transparent')
				this.titleArabic.classList.add('sm:bg-white')
				this.titleArabic.classList.add('sm:group-hover:text-shadow-lg')
				this.titleArabic.classList.add('shadow-black')
				this.titleArabic.classList.add('sm:group-hover:text-white')
				this.titleArabic.classList.add('sm:group-hover:bg-transparent')
				this.titleArabic.classList.add('pointer-events-none')
				this.titleArabic.setAttribute('dir', 'rtl')
			}

			// Add data-bg attribute to the element to load image later
			this.item.setAttribute('data-bg', `${story.storyImage.main}`)

			// Set highlighted if that's in the data
			if (story.highlighted) {
				this.item.classList.add('highlighted')
			} else {
				this.item.classList.remove('highlighted')
			}

			// Lazy load the image to replace the blurry placeholder
			if (!this.isImageLoaded()) {
				this.lazyLoadImage(story.storyImage.main, story.story[lang].title)
			}

			// Set to currently visible state for next drag
			this.visibleBeforeDrag = this.checkVisibility()

			// Add href to this grid item using slug
			this.item.setAttribute('href', `/stories/${lang}/${story.slugs[lang]}`)
		}

		// Method to lazy-load the preview images
		lazyLoadImage(fileName, altText) {
			// Create new image
			const img = new Image()

			// Start loading the image
			img.src = `${fileName}`

			// Store reference to the image in the class
			this.currentLoadingImage = img

			img.onload = () => {
				if (this.currentLoadingImage === img) {
					const imageElement = document.createElement('img')
					imageElement.src = img.src
					imageElement.classList.add('full-image')
					this.item.appendChild(imageElement)
					// This ensures the next repaint will have the image added but not visible
					requestAnimationFrame(() => {
						imageElement.classList.add('loaded')
					})
					if (altText) {
						// Add altText to image
						imageElement.setAttribute('alt', altText)
					}
				}
			}

			img.onerror = () => {
				console.error('Failed to load image:', fileName)
			}

			// Check if it was loaded immediately
			if (img.complete || img.readyState === 4) {
				wasLoadedFromCache = true
			}
		}
	}

	class Drag {
		constructor(ele, handleDrag) {
			this.dragging = false
			this.lastX = null
			this.lastY = null
			this.handleDrag = handleDrag
			this.touchStartTime = 0

			ele.addEventListener('click', this.onClick.bind(this), false)

			ele.addEventListener('touchstart', this.onStart.bind(this), false)
			ele.addEventListener('touchmove', this.onMove.bind(this), false)
			ele.addEventListener('touchend', this.onEnd.bind(this), false)

			ele.addEventListener('mousedown', this.onStart.bind(this))
			ele.addEventListener('mousemove', this.onMove.bind(this))
			ele.addEventListener('mouseup', this.onEnd.bind(this))
			// ele.addEventListener('mouseuot', this.onEnd.bind(this))
		}

		onClick(ev) {
			// Check if #grid is hidden and if yes return
			if (document.getElementById('grid').style.display === 'none') return
			ev = ev.type == 'touchstart' ? ev.touches[0] : ev

			if (this.dragging) {
				ev.preventDefault()
			}
		}

		onStart(ev) {
			if (document.getElementById('grid').style.display === 'none') return
			this.touchStartTime = Date.now()

			ev.preventDefault()

			// Add 'is-dragging' class to body to disable hover effects
			document.body.classList.add('is-dragging')

			ev = ev.type == 'touchstart' ? ev.touches[0] : ev

			this.dragging = true
			this.lastX = ev.clientX
			this.lastY = ev.clientY

			// Add 'hide-images' class to grid or image container to hide images
			document.getElementById('grid').classList.add('hide-images')
		}

		onMove(ev) {
			if (!this.dragging) return

			if (document.getElementById('grid').style.display === 'none') return
			ev = ev.type == 'touchmove' ? ev.touches[0] : ev

			let xDelta = ev.clientX - this.lastX
			let yDelta = ev.clientY - this.lastY
			let vel = Math.abs(xDelta * yDelta)
			if (vel > 50) {
				// let v = { x: xDelta * 0.5, y: yDelta * 1 } // Make it more snappy
				let v = { x: xDelta * 0, y: yDelta * 0 }
				if (this.anime) this.anime.pause()
				this.anime = anime({
					targets: v,
					x: 0,
					y: 0,
					update: () => {
						this.handleDrag(v.x, v.y)
					},
				})
			}

			this.handleDrag(xDelta, yDelta)
			this.lastX = ev.clientX
			this.lastY = ev.clientY
		}

		onEnd(ev) {
			this.dragging = false

			// Remove 'is-dragging' class from body
			document.body.classList.remove('is-dragging')

			// Remove 'hide-images' class to show images again
			document.getElementById('grid').classList.remove('hide-images')

			// Calculate the duration of the tap
			const touchDuration = Date.now() - this.touchStartTime

			// Check duration and act accordingly
			if (touchDuration < 50) {
				// This checks if the touch lasted less than 100ms
				// This was a short tap
				if (ev.target.tagName.toLowerCase() === 'a' && touchDuration) {
					const href = ev.target.getAttribute('href')
					if (href) {
						window.location = href
					}
				} else {
					return
				}
			}
		}
	}

	function debounce(func, wait, immediate) {
		var timeout
		return function () {
			var context = this,
				args = arguments
			var later = function () {
				timeout = null
				if (!immediate) func.apply(context, args)
			}
			var callNow = immediate && !timeout
			clearTimeout(timeout)
			timeout = setTimeout(later, wait)
			if (callNow) func.apply(context, args)
		}
	}

	class InfiniteGrid {
		constructor(nCol = 2, nRow = 2) {
			this.grid = document.getElementById('grid')
			this.container = document.getElementById('stories-container--grid')
			this.Drag = new Drag(this.container, this.onDrag.bind(this))
			this.offsetX = 0
			this.offsetY = 0
			this.SCROLL_DEBOUNCE = 0

			// Overshoot items
			this.items = []
			this.setGrid(nCol, nRow)

			// Scroll wheel event listener
			window.addEventListener('wheel', debounce(this.onScroll.bind(this), this.SCROLL_DEBOUNCE)) // Adjust debounce delay as needed
		}

		updateGridBackground(color) {
			this.grid.style.backgroundColor = color
		}

		onScroll({ deltaY }) {
			if (document.getElementById('grid').style.display === 'none') return

			const SCROLL_Y_THRESHOLD = 25

			const yDelta = deltaY
			this.offsetY += yDelta

			if (Math.abs(yDelta) < SCROLL_Y_THRESHOLD) return

			// Determine the scroll direction
			const direction = deltaY > 0 ? 1 : -1

			// Calculate the jump based on the direction of the scroll
			let jumpY = direction * Math.floor(Math.abs(Math.abs(yDelta)) / (100 / this.rows)) // Adjust the divisor based on your item height

			if (jumpY !== 0) {
				this.items.forEach((item) => {
					item.setIndex(this.shiftIndex(item.index + jumpY * this.cols))
				})

				// Reset offsetY after recalculating the indexes to avoid infinite growth
				this.offsetY = 0
			}

			// Update the grid position to reflect the new content
			this.grid.style.transform = `translate3d(0px, ${this.offsetY}px, 0)`
		}

		onDrag(xDelta, yDelta) {
			this.offsetX += xDelta
			this.offsetY += yDelta

			// Loop through all this.items elements and run checkVisibility method and then story this.isVisible in every item
			this.items.forEach((item) => {
				item.visibleBeforeDrag = item.checkVisibility()
			})

			// Move the grid back by 1 item whenever it goes over 1/2 of an item
			// Making the movement invisible
			const itemWidth = 100 / this.cols
			const itemHeight = 100 / this.rows
			const pixelWidth = (itemWidth * window.innerWidth) / 100
			const pixelHeight = (itemHeight * window.innerHeight) / 100
			let jumpX = null
			let jumpY = null

			if (Math.abs(this.offsetX) > pixelWidth / 2) {
				this.offsetX -= pixelWidth * Math.sign(this.offsetX)
				jumpX = Math.sign(this.offsetX)
			}

			if (Math.abs(this.offsetY) > pixelHeight / 2) {
				this.offsetY -= pixelHeight * Math.sign(this.offsetY)
				jumpY = Math.sign(this.offsetY)
			}

			if (jumpX || jumpY) {
				this.items.forEach((item) => {
					if (jumpX) item.setIndex(this.shiftIndex(item.index + jumpX))
					if (jumpY) item.setIndex(this.shiftIndex(item.index + jumpY * (this.cols + 2)))
				})
			}

			this.grid.style.transform = `translate3d(${this.offsetX}px,${this.offsetY}px,0)`
		}

		shiftIndex(index) {
			if (index < 0) {
				index = this.items.length + index
			}
			index = index % this.items.length
			return index
		}

		async setGrid(nCol = 2, nRow = 2) {
			if (nCol === this.cols && nRow === this.rows) return

			// Overshoot items
			const cols = nCol + 2
			const rows = nRow + 2

			// Add space for 2 more rows and columns using the current col/row size
			this.container.style.width = `${100 + (100 / nCol) * 2}vw`
			this.container.style.height = `${100 + (100 / nRow) * 2}vh`

			// Move the grid back by 1 col and row
			this.container.style.transform = `translate(${-100 / nCol}vw, ${-100 / nRow}vh)`

			// Do everything else taking into account the overshoot items
			this.grid.style.gridTemplateColumns = Array.from({ length: cols }, () => '1fr').join(' ')
			this.grid.style.gridTemplateRows = Array.from({ length: rows }, () => '1fr').join(' ')

			const nItems = cols * rows
			this.cols = nCol
			this.rows = nRow

			while (nItems < this.items.length) {
				this.grid.removeChild(this.grid.children[this.items.length - 1])
				this.items = this.items.slice(0, this.items.length - 1)
			}

			while (nItems > this.items.length) {
				const item = new GridItem(this.items.length)
				this.items = this.items.concat(item)
				this.grid.append(item.item)
			}

			this.items.forEach((item, index) => {
				item.setIndex(index)
			})

			// Infinite.updateGridBackground('black')
		}
	}

	const grid = optimalGridDimensions()
	const Infinite = new InfiniteGrid(grid.cols, grid.rows)

	function optimalGridDimensions(minSide = window.innerWidth > 640 ? 220 : 140) {
		const width = window.innerWidth
		const height = window.innerHeight

		const maxCols = Math.floor(width / minSide)
		const maxRows = Math.floor(height / minSide)

		let bestCols = 1
		let bestRows = maxRows
		let closestToSquare = Infinity

		for (let cols = 1; cols <= maxCols; cols++) {
			const cellWidth = width / cols
			const rowsForSquare = Math.floor(height / cellWidth)

			if (rowsForSquare > 0 && cellWidth >= minSide) {
				const aspectRatioDiff = Math.abs(cellWidth * cols - (width * rowsForSquare) / height)

				if (aspectRatioDiff < closestToSquare) {
					closestToSquare = aspectRatioDiff
					bestCols = cols
					bestRows = rowsForSquare
				}
			}
		}

		return {
			cols: bestCols,
			rows: bestRows,
		}
	}

	// Re-calculate when user resizes browser
	window.addEventListener('resize', () => {
		const grid = optimalGridDimensions()
		Infinite.setGrid(grid.cols, grid.rows).then(() => {
			console.log('Grid loaded')
			Infinite.updateGridBackground('black')
		})
	})
</script>
