---
const { stories } = Astro.props

let { lang } = Astro.params

if (!lang) {
	// Read path parameters for language and slug on server side
	const { path } = Astro.params

	const pathParams = path?.toString().split('/')
	lang = pathParams?.[0] || 'en'
}
---

<div class='grid-container' id='js-grid'></div>

<!-- HammerJS -->
<script is:inline src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/hammer.min.js'></script>

<!-- GSAP -->
<script is:inline src='https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js'></script>

<script is:inline define:vars={{ lang, stories }}>
	// Set to identify the stories that have been picked
	let setOfIDs = new Set()

	// Utility function to shuffle an array (e.g., Fisher-Yates shuffle algorithm)
	function shuffleArray(array) {
		for (let i = array.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1))
			;[array[i], array[j]] = [array[j], array[i]] // swap elements
		}
	}

	// Assuming stories is an array of story objects
	let shuffledStories = [...stories] // Clone and shuffle the stories array
	shuffleArray(shuffledStories)

	// Throttle function
	function throttle(func, limit) {
		let inThrottle
		return function () {
			const args = arguments
			const context = this
			if (!inThrottle) {
				func.apply(context, args)
				inThrottle = true
				setTimeout(() => (inThrottle = false), limit)
			}
		}
	}

	// Debounce function
	function debounce(func, wait, immediate) {
		var timeout
		return function () {
			var context = this,
				args = arguments
			var later = function () {
				timeout = null
				if (!immediate) func.apply(context, args)
			}
			var callNow = immediate && !timeout
			clearTimeout(timeout)
			timeout = setTimeout(later, wait)
			if (callNow) func.apply(context, args)
		}
	}

	// Apply card size function
	function adjustAndApplyCardSize() {
		const newSize = calculateGridDimensions() // Recalculate sizes
		// Apply new sizes to all cards
		document.querySelectorAll('.card').forEach((card) => {
			card.style.width = `${newSize.cardSize}px`
			card.style.height = `${newSize.cardSize}px`
		})
		// Here, also handle the grid layout adjustments if necessary
	}

	// Adjust card size function
	function calculateGridDimensions() {
		let rows = 10
		let cols = 10
		let targetSize = 320
		let margin = 20

		if (window.innerWidth < 1400) {
			rows = 10
			cols = 10
			targetSize = 280
			margin = 15
		}

		if (window.innerWidth < 1280) {
			rows = 10
			cols = 10
			targetSize = 250
			margin = 10
		}

		if (window.innerWidth < 640) {
			rows = 3
			cols = 3
			margin = 5
			targetSize = window.innerWidth / 2
		}

		const FIXED_ROWS = rows
		const FIXED_COLS = cols
		const TARGET_SIZE = targetSize

		const viewportWidth = window.innerWidth
		const viewportHeight = window.innerHeight

		// Assuming you have a dynamic way to set these based on the viewport or a fixed value
		const targetColumns = Math.min(Math.floor(viewportWidth / TARGET_SIZE), FIXED_COLS) // e.g., 5 or less
		const targetRows = Math.min(Math.floor(viewportHeight / TARGET_SIZE), FIXED_ROWS) // e.g., 5 or less

		// Calculate available space taking into account some margin/padding if necessary
		const totalMarginWidth = margin * (targetColumns + 1)
		const totalMarginHeight = margin * (targetRows + 1)

		const availableWidth = viewportWidth - totalMarginWidth
		const availableHeight = viewportHeight - totalMarginHeight

		// Calculate the max card size that can fit the current viewport
		const maxCardWidth = availableWidth / targetColumns
		const maxCardHeight = availableHeight / targetRows

		const cardSize = Math.min(maxCardWidth, maxCardHeight) - 20 // Ensure 1:1 aspect ratio

		return { cardSize, targetColumns, targetRows }
	}

	class SimpleDrag {
		constructor(DOMElement, onDrag) {
			this.useTouch = this.isTouch()
			this.dragging = false
			this.lastX = 0
			this.lastY = 0
			this.tween = undefined
			this.prevVelocity = 0
			this.DOMElement = DOMElement
			this.onDragCallback = onDrag
			this.bind()
			this.touchStartTime = 0
		}

		onMove(e) {
			if (this.dragging) {
				e = e.type == 'touchmove' ? e.touches[0] : e

				let xDelta = e.clientX - this.lastX
				let yDelta = e.clientY - this.lastY

				// Example of using TweenMax to smoothly transition an element
				// based on the drag. This code assumes you are applying a visual effect
				// rather than moving the element with the mouse.
				TweenMax.to(this.DOMElement, 0.5, {
					x: '+=' + xDelta,
					y: '+=' + yDelta,
					ease: Power1.easeOut,
					onUpdate: () => {
						// Optionally, you can perform actions on update
						// For moving the element in real-time, it's better to apply the position directly.
					},
				})

				this.onDragCallback(xDelta, yDelta)

				this.lastX = e.clientX
				this.lastY = e.clientY
			}
		}

		onStart(e) {
			e = e.type == 'touchstart' ? e.touches[0] : e

			this.lastX = e.clientX
			this.lastY = e.clientY

			this.dragging = true

			// console.log(this.lastX, this.lastY)

			// Record touch start time
			this.touchStartTime = Date.now()

			// Add .is-dragging to body to prevent text selection
			document.body.classList.add('is-dragging')
		}

		onEnd(e) {
			e.preventDefault()

			this.dragging = false

			// Remove is-dragging from body
			document.body.classList.remove('is-dragging')

			// Calculate the duration of the tap
			const touchDuration = Date.now() - this.touchStartTime

			const maxTouchDuration = window.innerWidth > 640 ? 200 : 175

			// Check duration and act accordingly
			if (touchDuration < maxTouchDuration) {
				// console.log(touchDuration)

				// This checks if the touch lasted less than 100ms
				const href = e.target.getAttribute('data-href')
				if (href) {
					window.location = href
				}
			}
		}

		isTouch() {
			return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
		}

		bind() {
			let el = this.DOMElement

			if (this.useTouch) {
				el.addEventListener('touchstart', this.onStart.bind(this), false)
				el.addEventListener('touchmove', this.onMove.bind(this), false)
				el.addEventListener('touchend', this.onEnd.bind(this), false)
			} else {
				el.addEventListener('mousedown', this.onStart.bind(this), false)
				el.addEventListener('mousemove', this.onMove.bind(this), false)
				el.addEventListener('mouseup', this.onEnd.bind(this), false)
			}
		}
	}

	class Card {
		constructor(descriptor, lastRead) {
			this.descriptor = descriptor
			this.createDOMElement()
			this.x = 0
			this.y = 0
			this.lastRead = lastRead
		}

		createDOMElement() {
			this.rootElement = document.createElement('div')
			this.rootElement.setAttribute('backgroundImage', `url(${this.descriptor.storyImage.pixelated})`)
			this.rootElement.classList.add('bg-zinc-950')
			this.rootElement.classList.add('opacity-0')

			// Set href for the card
			this.rootElement.setAttribute('data-href', `/stories/${lang}/${this.descriptor.slugs[lang]}`)

			this.imgElement = document.createElement('img')
			this.rootElement.className = 'card'
			if (this.descriptor.highlighted) {
				this.rootElement.classList.add('highlighted')
			}
			this.rootElement.appendChild(this.imgElement)

			// Append empty and transparent div to rootElement to paint it later
			const emptyDiv = document.createElement('div')
			emptyDiv.classList.add('shader')
			emptyDiv.classList.add('pointer-events-none')
			emptyDiv.classList.add('w-full')
			emptyDiv.classList.add('h-full')
			emptyDiv.classList.add('absolute')
			emptyDiv.classList.add('top-0')
			emptyDiv.classList.add('left-0')
			emptyDiv.classList.add('bg-gradient-to-b')
			emptyDiv.classList.add('from-black')
			emptyDiv.classList.add('via-black')
			emptyDiv.classList.add('to-transparent')
			emptyDiv.classList.add('opacity-0')
			this.rootElement.appendChild(emptyDiv)

			// Create div element as a wrapper for the highlighted text

			// Create a h3 element and append to rootElement
			const starDiv = document.createElement('div')
			starDiv.classList.add('flex')
			starDiv.classList.add('items-center')
			starDiv.classList.add('justify-center')
			starDiv.classList.add('absolute')
			starDiv.classList.add('bottom-3')
			starDiv.classList.add('right-3')
			starDiv.classList.add('w-8')
			starDiv.classList.add('h-8')
			starDiv.classList.add('m-0')
			starDiv.classList.add('p-2')
			starDiv.classList.add('rounded-full')
			starDiv.classList.add('bg-burgundy')
			starDiv.classList.add('pointer-events-none')
			starDiv.classList.add('shadow-lg')
			starDiv.classList.add('shadow-black')
			starDiv.classList.add('hidden')
			starDiv.classList.add(this.descriptor.highlighted ? 'opacity-80' : 'opacity-0')

			const highlightedText = document.createElement('span')
			highlightedText.textContent = 'â˜…'
			highlightedText.classList.add('text-white')
			highlightedText.classList.add('text-base')
			highlightedText.classList.add('p-0')
			highlightedText.classList.add('m-0')
			highlightedText.classList.add('font-serif')

			starDiv.appendChild(highlightedText)
			this.rootElement.appendChild(starDiv)

			// Create h2 title and append to rootElement
			const titleText =
				!this.descriptor.story[lang].title || this.descriptor.story[lang].title === ''
					? 'NO TITLE FOR ID ' + this.descriptor.id
					: this.descriptor.story[lang].title
			let title = document.createElement('h2')
			title.textContent = titleText
			title.classList.add('grid-tile--title')
			title.classList.add('shadow-black')
			title.classList.add('text-shadow-xl')
			title.classList.add('w-full')
			if (lang === 'ar') {
				title.classList.add('text-right')
				title.setAttribute('dir', 'rtl')
			} else {
				title.classList.add('text-left')
				title.setAttribute('dir', 'ltr')
			}
			this.titleElement = title
			this.rootElement.appendChild(title)
		}

		load() {
			let { imgElement } = this
			if (imgElement.src !== this.descriptor.storyImage.main) {
				imgElement.src = this.descriptor.storyImage.main
				imgElement.onload = () => {
					this.update()
					this.rootElement.classList.toggle('hidden', false)
				}
			}
		}

		appendTo(el) {
			if (this.rootElement.parentElement !== el) {
				el.appendChild(this.rootElement)
				this.load()
			}
		}

		removeSelf() {
			if (this.rootElement.parentElement) {
				this.rootElement.classList.toggle('hidden', true)
				this.imgElement.src = ''
				this.rootElement.parentElement.removeChild(this.rootElement)
			}
		}

		update() {
			if (!this.lastRead) {
				// Don't bother with this if it's not on "unread only" filter
			} else {
				debounce(this.rootElement.setAttribute('data-lastread', this.lastRead), 500)
			}

			// Replace link data attribute
			this.rootElement.setAttribute('data-href', `/stories/${lang}/${this.descriptor.slugs[lang]}`)

			// Create h2 title and append to rootElement
			const titleText =
				!this.descriptor.story[lang].title || this.descriptor.story[lang].title === ''
					? 'NO TITLE FOR ID ' + this.descriptor.id
					: this.descriptor.story[lang].title
			// Find h2 element and replace its text content
			this.titleElement.textContent = titleText

			let cssBatch = ''
			cssBatch += `transform: translate3d(${this.x}px, ${this.y}px, 0);`
			cssBatch += `width: ${calculateGridDimensions().cardSize - 8}px;`
			cssBatch += `height: ${calculateGridDimensions().cardSize - 8}px;`
			cssBatch += `background-image: url(${this.descriptor.storyImage.pixelated})`

			this.rootElement.setAttribute('style', cssBatch)
		}
	}

	class Grid {
		constructor(DOMElement, STORIES) {
			this.descriptors = STORIES
			this.DOMElement = DOMElement
			// Dict to save previous assignations by col and row
			this.picks = {}
			// Counter to track the selection of highlighted stories
			this.highlightedCounter = 0
			// Current visible cards
			this.cards = {}
			// All elements are cached and reused
			this.cardsPool = []
			this.recentIDs = new Set()
			this.offsetX = 0
			this.offsetY = 0
			this.viewCols = 0
			this.viewRows = 0
			this.viewWidth = 0
			this.viewHeight = 0
			this.readArticles = JSON.parse(localStorage.getItem('readArticles')) || []
			this.init()
		}

		init() {
			window.addEventListener('resize', debounce(this.onResize.bind(this)), 250)
			this.onResize()
			// this.adjustInitialXOffset()
			let d = new SimpleDrag(this.DOMElement, this.onDrag.bind(this))

			if (window.innerWidth > 500) {
				// Add functionality for arrow keys
				window.addEventListener('keydown', this.onKeyDown.bind(this))
			}

			window.addEventListener(
				'wheel',
				throttle(
					function (event) {
						this.onMouseWheel(event)
					}.bind(this),
					100,
				),
			)
		}

		adjustInitialXOffset() {
			if (this.dragging) return

			// Define your mobile breakpoint
			// Assuming calculateGridDimensions().cardSize gives you the card width
			const cardWidth = calculateGridDimensions().cardSize
			// Generate a random fraction between 1/2 and 1/3
			const randomFraction = Math.random() * (1 / 2 - 2 / 4) + 1 / 4
			// Calculate the shift amount based on the random fraction
			const shiftAmount = cardWidth * randomFraction
			// Shift grid elements to the left by the calculated shift amount
			this.offsetX -= shiftAmount
			// this.lastX -= shiftAmount
		}

		getGalleryDescriptor(index) {
			// console.log(this.descriptors.length)
			return this.descriptors[index % this.descriptors.length]
		}

		onDragEnd() {
			// this.DOMElement.classList.remove( "hover-enabled" );
			// this.DOMElement.classList.add('hover-enabled')
		}

		onDrag(deltaX, deltaY) {
			//this.DOMElement.classList.remove( "hover-enabled" );
			//console.log( e );
			this.offsetX += deltaX
			this.offsetY += deltaY
			this.updateGrid()
		}

		onResize() {
			this.viewHeight = this.DOMElement.offsetHeight
			this.viewWidth = this.DOMElement.offsetWidth
			this.updateViewColRows()
			this.updateGrid()
		}

		// Handle keyboard arrow key presses
		onKeyDown(event) {
			const { keyCode } = event

			switch (keyCode) {
				case 37: // Left arrow key
					this.offsetX += calculateGridDimensions().cardSize / 4
					break
				case 38: // Up arrow key
					this.offsetY += calculateGridDimensions().cardSize / 4
					break
				case 39: // Right arrow key
					this.offsetX -= calculateGridDimensions().cardSize / 4
					break
				case 40: // Down arrow key
					this.offsetY -= calculateGridDimensions().cardSize / 4
					break
				default:
					return // Exit function for other keys
			}

			// Update the grid position based on arrow key inputs
			this.updateGrid()
		}

		// Handle mouse wheel event
		onMouseWheel(event) {
			if (localStorage.getItem('menuOpen') === 'true') return

			const deltaY = event.deltaY

			// Update the grid position based on the direction of the mouse wheel scroll
			this.offsetY += deltaY > 0 ? -calculateGridDimensions().cardSize / 2 : calculateGridDimensions().cardSize / 2

			// Update the grid
			this.updateGrid()
		}

		updateViewColRows() {
			this.viewCols = Math.ceil(this.viewWidth / calculateGridDimensions().cardSize) + 2
			this.viewRows = Math.ceil(this.viewHeight / calculateGridDimensions().cardSize) + 2
		}

		isVisible(x, y) {
			// return x + CARD_WIDTH > 0 && y + CARD_HEIGHT > 0 && x < this.viewWidth && y < this.viewHeight

			return (
				x + calculateGridDimensions().cardSize > -calculateGridDimensions().cardSize &&
				y + calculateGridDimensions().cardSize > 0 &&
				x < this.viewWidth + calculateGridDimensions().cardSize &&
				y < this.viewHeight + calculateGridDimensions().cardSize
			)
		}

		getRandomSafe() {
			let availableStories

			// Determine if we should allow a highlighted story based on the counter
			if (this.highlightedCounter < 20) {
				// Exclude highlighted stories if the counter is less than 9
				availableStories = shuffledStories.filter((story) => !this.recentIDs.has(story.id) && story.highlighted !== true)
			} else {
				// Allow all stories, including highlighted ones
				availableStories = shuffledStories.filter((story) => !this.recentIDs.has(story.id))
			}

			if (availableStories.length === 0) {
				// If no suitable stories are available (or all have been used), reset the tracking and reshuffle
				this.recentIDs.clear()
				shuffleArray(shuffledStories)
				this.highlightedCounter = 0 // Reset the highlighted counter as well
				// Repeat the filter process after reshuffling
				return this.getRandomSafe()
			} else {
				const selectedStory = availableStories[0] // Pick the first available story
				this.recentIDs.add(selectedStory.id)

				// Update the highlighted counter based on the selected story
				if (selectedStory.highlighted === true) {
					this.highlightedCounter = 0 // Reset counter if a highlighted story is selected
				} else {
					this.highlightedCounter++ // Increment counter for a non-highlighted story
				}

				// Optionally, limit the size of recentIDs to manage memory and ensure variety
				if (this.recentIDs.size > stories.length) {
					const oldestId = Array.from(recentIDs)[0]
					this.recentIDs.delete(oldestId)
				}

				return selectedStory
			}
		}

		getRandomDescriptor(col, row) {
			let key = `${col}:${row}`

			// Check if the item is already assigned
			if (!this.picks[key]) {
				let item = this.getRandomSafe(col, row)
				this.picks[key] = item
			}
			return this.picks[key]
		}

		getCardPos(col, row) {
			// Calculate the position of the card
			let offsetX = this.offsetX % calculateGridDimensions().cardSize
			let offsetY = this.offsetY % calculateGridDimensions().cardSize
			let x = col * calculateGridDimensions().cardSize + offsetX - calculateGridDimensions().cardSize
			let y = row * calculateGridDimensions().cardSize + offsetY - calculateGridDimensions().cardSize
			return [Math.round(x), Math.round(y)]
		}

		updateGrid() {
			let newCards = {}
			let colOffset = ~~(this.offsetX / calculateGridDimensions().cardSize) * -1
			let rowOffset = ~~(this.offsetY / calculateGridDimensions().cardSize) * -1

			// Loop through the visible cards
			for (let row = -1; row < this.viewRows; row++) {
				for (let col = -1; col < this.viewCols; col++) {
					let desc = undefined
					let tCol = colOffset + col
					let tRow = rowOffset + row
					if (tCol > 0 && tRow > 0 && tCol < calculateGridDimensions().cols && tRow < calculateGridDimensions().rows) {
						let index = tRow * calculateGridDimensions().cols + tCol
						desc = this.getGalleryDescriptor(index)
					} else {
						desc = this.getRandomDescriptor(tCol, tRow)
					}

					let [x, y] = this.getCardPos(col, row)

					if (this.isVisible(x, y)) {
						let index = tCol + '' + tRow
						let card = this.cards[index] || this.getCard(desc)
						delete this.cards[index]
						card.x = x
						card.y = y
						card.appendTo(this.DOMElement)
						card.update()
						newCards[index] = card
					}
				}
			}

			this.cleanupCards()
			this.cards = newCards
		}

		cleanupCards() {
			let keys = Object.keys(this.cards)
			for (let i = 0; i < keys.length; i++) {
				let card = this.cards[keys[i]]
				card.removeSelf()
				this.cardsPool.push(card)
			}
			this.cards = null
		}

		getCard(descriptor) {
			if (this.cardsPool.length > 0) {
				let card = this.cardsPool.pop()
				card.descriptor = descriptor
				return card
			} else {
				// Find out if descriptor is in readArticles
				const readArticle = this.readArticles.find((article) => article.slug === descriptor.slugs[lang])
				// console.log(readArticle)
				// return new Card(descriptor, readArticle?.timestamp || 'never')
				return new Card(descriptor, readArticle ? readArticle.timestamp : 'never')
			}
		}
	}

	// Create grid and initialize it
	let grid = new Grid(document.getElementById('js-grid'), stories)
	grid.init()

	// Adjust card size on resize
	window.addEventListener('resize', throttle(adjustAndApplyCardSize, 250))
</script>

<style is:global lang='scss'>
	body {
		background: black;
		margin: 0;
	}

	.grid-container {
		direction: ltr !important;
		user-select: none;
		width: 100vw;
		height: 100vh;
		/* Add iOS screen height fix */
		height: -webkit-fill-available;
		position: fixed;
		z-index: -1;
		cursor: grab;
		cursor: -moz-grab;
		cursor: -webkit-grab;
	}

	.grid-container:active {
		cursor: grabbing;
		cursor: -moz-grabbing;
		cursor: -webkit-grabbing;
	}

	.card img {
		position: absolute;
		pointer-events: none;
		user-select: none;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		object-fit: cover;
	}

	.card {
		background-color: #292929;
		position: relative;
		background-size: cover;
		background-position: center;
		border-radius: 1px;
		direction: rtl;
		text-align: right;
		opacity: 1;
		overflow: hidden;
		position: absolute;
		border: 3px solid rgba(255, 255, 255, 0.1);
		opacity: 1;
		transition: opacity 0.5s;
		will-change: transform, opacity;

		@media screen and (max-width: 640px) {
			border: 2px solid #666;
		}
	}

	#js-grid.filter--read .card:not([data-lastread='never']) {
		opacity: 0.2;
	}

	#js-grid.filter--read .card:not([data-lastread='never']),
	#js-grid.filter--read .card:not([data-lastread='never']):hover,
	#js-grid.filter--read .card:not([data-lastread='never']):hover * {
		cursor: move;
	}

	.card {
		.shader {
			opacity: 0.5;
			transition: all 0.5s;
			will-change: opacity;
		}

		h2 {
			pointer-events: none;
		}
	}

	body:not(.is-dragging) {
		.card:hover {
			opacity: 1;
			border: 3px solid white;

			h2 {
				text-shadow: inherit;
				background: transparent;
			}

			@media screen and (max-width: 640px) {
				border: 2px solid #444;
			}

			.shader {
				opacity: 0;

				@media screen and (max-width: 640px) {
					// opacity: 0;
				}
			}
		}

		.card.highlighted {
			&:not(:hover) {
				border-color: #9f3e52;
			}

			h2 {
				display: inline;
				width: auto;
				text-shadow: none;
				box-decoration-break: clone;
				left: 0;
				// padding: 0.3rem 0.5rem 0.6rem 0.5rem;
				// background: #9f3e52;

				&[dir='rtl'] {
					right: 0;
					left: unset;
				}

				@media screen and (max-width: 640px) {
					border-color: #9f3e52;
				}
			}
		}
	}

	.card.hidden {
		opacity: 0;
	}

	.card img {
		width: 100%;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
	}

	.card h2 {
		font-weight: semibold;
		color: white;
		position: absolute;
		top: 0;
		margin: 0;
		padding: 0.25rem 0.5rem;
		font-size: 1.4rem;

		@media screen and (max-width: 640px) {
			font-size: 1rem;
			font-weight: normal;
		}
	}
</style>
